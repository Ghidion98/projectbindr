var c=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;function a(n){return typeof n=="string"&&c.test(n)}const e=[];for(let n=0;n<256;++n)e.push((n+256).toString(16).slice(1));function y(n,t=0){return(e[n[t+0]]+e[n[t+1]]+e[n[t+2]]+e[n[t+3]]+"-"+e[n[t+4]]+e[n[t+5]]+"-"+e[n[t+6]]+e[n[t+7]]+"-"+e[n[t+8]]+e[n[t+9]]+"-"+e[n[t+10]]+e[n[t+11]]+e[n[t+12]]+e[n[t+13]]+e[n[t+14]]+e[n[t+15]]).toLowerCase()}let o;const g=new Uint8Array(16);function f(){if(!o){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");o=crypto.getRandomValues.bind(crypto)}return o(g)}const p=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);var u={randomUUID:p};function m(n,t,r){if(u.randomUUID&&!t&&!n)return u.randomUUID();n=n||{};const d=n.random??n.rng?.()??f();if(d.length<16)throw new Error("Random bytes length must be >= 16");if(d[6]=d[6]&15|64,d[8]=d[8]&63|128,t){if(r=r||0,r<0||r+16>t.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let i=0;i<16;++i)t[r+i]=d[i];return t}return y(d)}export{m as v4,a as validate};
